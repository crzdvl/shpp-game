<!DOCTYPE html>
<html lang = 'en'>

<head>
    <meta charset="utf-8">
    <title>Hello World</title>
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css?family=Play">
    <style>
        body {
            margin: 0%;
            padding: 0%;
            overflow:hidden;
        }
    </style>
</head>

<script src="https://pixijs.download/v6.1.0-rc.2/pixi.js"></script>

<body>
    <script>
        di = document.createElement("div")
        di.style.position = 'absolute'
        di.style.width = innerWidth + "px";
        di.style.transition = "background-color 2s"
        di.style.transition = "background 2s linear"
        di.style.height = innerHeight + "px";
        di.style.backgroundColor = "#DAF7A6";
        di.style.backgroundColors = "blue";
        di.style.color = "white";
        document.body.appendChild(di)

        app = new PIXI.Application({
            transparent: true,
            width: document.body.offsetWidth,
            height: innerHeight - 4,
            backgzColor: 0xffffff,
        })
        app.renderer.view.style.position = "absolute"
        //конфиг------------------------------------------------------------------------------------------------------
        let Width = innerWidth
        const config = {
            replics: {
                start: [
                    "Здравствуй!",
                    "Кажется ты ::нашёл нечто скрытое",
                    "Для управления ::пользуйся стрелочками",
                    "Поехали!",
                    "3",
                    "2",
                    "1",
                ],
            },
            animGoldPlusSpeed: Width / 280, //speed anim
            rotationRandomizer: (0.025 - 0.018) + 0.018, //random speed rotate plus
            catchedPlusesDist: (Width / 10) / 1.5, 
            greyDist: (Width / 10) / 2.5, //dist between sh and grey plua
            gravity: 0.4, 
            fontSize: Width / 10, 
            fallingPlusesSpeed: (Width / 250), 
            shStartXPosition: Width / 2 - (Width / 10) / 2, 
            shSpeed: Math.floor((Width / 10) * 0.2), 
            scorePositionX: Width - Width / 10, 
            minSpeed: Width / 230, //speed falin pluses
            center: { //center of display
                x: Width / 2,
                y: innerHeight / 2
            },
            sizesForSpeedRandom: { //random speed
                y: (Width / 290) - (Width / 230)
            },
            sizesForRandom: { //blast random
                x: 15 - (-15) + 1 - 15,
                y: -12 - 17,
            },
            styles: { //objects styles ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
                greenPlus: new PIXI.TextStyle({ 
                    fill: "green",
                    lineJoin: "round",
                    stroke: 'green',
                    fontSize: Width / 10,
                    strokeThickness: 4,
                }),

                grayPlus: new PIXI.TextStyle({ 
                    fill: "gray",
                    lineJoin: "round",
                    fontSize: Width / 10,
                    strokeThickness: 4,
                }),

                RotatePlus: new PIXI.TextStyle({ 
                    fill: "#add8e6",
                    lineJoin: "round",
                    fontSize: Width / 10,
                    strokeThickness: 4,
                    stroke: "#add8e6"
                }),

                blackPlus: new PIXI.TextStyle({ 
                    fill: "black",
                    lineJoin: "round",
                    fontSize: Width / 10,
                    strokeThickness: 4,
                    stroke: "black"
                }),

                goldPlus: new PIXI.TextStyle({ 
                    fill: "yellow",
                    stroke: "yellow",
                    lineJoin: "round",
                    fontSize: Width / 10,
                    strokeThickness: 4,
                }),

                sh: new PIXI.TextStyle({ 
                    fill: "black",
                    lineJoin: "round",
                    fontSize: Width / 10,
                    strokeThickness: 4,
                }),

                score: new PIXI.TextStyle({ 
                    fill: 'green',
                    fontSize: Width / 15,
                    lineJoin: "round",
                    stroke: 'green',
                    strokeThickness: 4,
                }),
            },
        }
        //стейт-------------------------------------------------------------------------------------------------------
        let state = {
            startText: 0,
            shRealSize: PIXI.TextMetrics.measureText("Ш", config.styles.sh),
            plusRealSize: PIXI.TextMetrics.measureText("+", config.styles.greenPlus),
            scoreObject: new PIXI.Text("0", config.styles.score),
            sh: new PIXI.Text("Ш", config.styles.sh),
            greyPlus: new PIXI.Text("+", config.styles.grayPlus),
            deadPlus: {
                value: 0
            }, //number dead plus
            deadGoldPlus: {
                value: 0
            }, //number dead gold plus
            canAnimTransform: false, //start anim gold plus
            pushPlusNextSh: false, //start push plus next sh
            rightPressed: false, //if right arrow pressed
            leftPressed: false, //if left arrow pressed
            difficult: 0,//levels of difficulty
            replic: 0, //replics counter
            stop: false, //stop game
            gravity: 0,
            intervalOfFallingPluses: {
                falling: 700
            },
            plusFell: true, //if plus fell
            timeWhenFunctionsDone: 0, 
            timeNow: 0,
            score: 0,
            scoreSpeed: 0, 
            scoreAnimSwitch: false, 
            scoreAnimDo: false, 
            scoreColorAlpha: 1, 
            scoreAnimRemoveVariables: false,
            catchedGoldPluses: 0, //how many gold pluses
            allGoldCatched: true, 
            pluses: { 
                falling: [],
                onPlace: [], //caught pluses
                boom: [], //grey boom pluses
                Transform: [],//pluses which used to anim gold plus
                gold: [],
            },
            shSizes: { 
                x: 0,
                y: 0,
                h: 0,
                w: 0,
            },

        }
        //Подключение слушателей событий -----------------------------------------------------------------------------
        document.addEventListener("keydown", KeyDownHandler, false);
        document.addEventListener("keyup", KeyUpHandler, false);
        //ИнициализацияСтейта-----------------------------------------------------------------------------------------
        function initialization() {
            state.stop = false
            state.greyPlus.shag = {}
            state.greyPlus.shag.x = Math.floor(Math.random() * (config.sizesForRandom.x));
            state.greyPlus.shag.y = Math.floor(Math.random() * (config.sizesForRandom.y));
            state.greyPlus.rotationStep = Math.random() * config.rotationRandomizer;
            state.sh.x = config.shStartXPosition
            state.sh.y = innerHeight - state.shRealSize.height
            state.sh.shag = {}
            state.sh.shag.x = Math.floor(Math.random() * (config.sizesForRandom.x));
            state.sh.shag.y = Math.floor(Math.random() * (config.sizesForRandom.y));
            state.sh.angle = 0;
            state.sh.rotationStep = Math.random() * config.rotationRandomizer;
            state.scoreObject.x = config.scorePositionX;
            document.body.appendChild(app.view);
            app.stage.addChild(state.scoreObject)
            app.stage.addChild(state.sh)
            app.stage.addChild(state.greyPlus)
        }

        initialization();
        //функция округления------------------------------------------------------------------------------------------
        function round(numb, float) {
            return +numb.toFixed(float);
        }
        /*=============================================================================================
        PUSHING ALL
        =============================================================================================*/
        //Функция которая пушит плюсы для взрыва когда Ш убита -------------------------------------------------------
        function pushBoomPluses(lastPlus, parentPlus) {
            lastPlus.x = parentPlus.x;
            lastPlus.y = parentPlus.y;
            lastPlus.rotationStep = Math.random() * config.rotationRandomizer;
            lastPlus.xShag = Math.floor(Math.random() * config.sizesForRandom.x);
            lastPlus.yShag = Math.floor(Math.random() * config.sizesForRandom.y);
            state.pluses.gravity = 0.4;
            app.stage.addChild(lastPlus)
        }

        function BoomPush() {
            if (state.pluses.onPlace.length > 0 && state.deadPlus.value > 0) {
                for (let a = state.deadPlus.value - 1; a < state.pluses.onPlace.length; a++) {
                    state.pluses.boom.push(new PIXI.Text("+", config.styles.grayPlus))
                    let lastPlus = state.pluses.boom[state.pluses.boom.length - 1]
                    pushBoomPluses(lastPlus, state.pluses.onPlace[a])
                }
            }
            if (state.pluses.gold.length > 0 && state.deadGoldPlus.value > 0) {
                for (let a = state.deadGoldPlus.value - 1; a < state.pluses.gold.length; a++) {
                    state.pluses.boom.push(new PIXI.Text("+", config.styles.grayPlus))
                    let lastPlus = state.pluses.boom[state.pluses.boom.length - 1]
                    pushBoomPluses(lastPlus, state.pluses.gold[a])
                    console.log(state.deadGoldPlus.value)
                }
            }
        }
        //Функция которая создаёт новый плюс и закидывает его в массив------------------------------------------------
        function createPlus(lastPlus) {
            lastPlus.catched = false;
            lastPlus.onPlace = false;
            lastPlus.kill = false;
            if (state.difficult === 0) {
                lastPlus.speed = round((config.minSpeed + (config.sizesForSpeedRandom.y * Math.random())), 2)
            }
            if (state.difficult === 1) {
                lastPlus.speed = round((config.minSpeed + (config.sizesForSpeedRandom.y * Math.random())), 2) + config.fallingPlusesSpeed * 0.2
            }
            if (state.difficult === 2) {
                lastPlus.speed = round((config.minSpeed + (config.sizesForSpeedRandom.y * Math.random())), 2) + config.fallingPlusesSpeed * 0.4
                state.intervalOfFallingPluses.falling = 400
            }
            if (state.difficult === 3) {
                lastPlus.speed = round((config.minSpeed + (config.sizesForSpeedRandom.y * Math.random())), 2) + config.fallingPlusesSpeed * 0.6
                state.intervalOfFallingPluses.falling = 300
            }
            if (state.difficult === 4) {
                lastPlus.speed = round((config.minSpeed + (config.sizesForSpeedRandom.y * Math.random())), 2) + config.fallingPlusesSpeed * 0.8
                state.intervalOfFallingPluses.falling = 150
            }
            lastPlus.rotationStep = round((Math.random() * config.rotationRandomizer), 2)
            lastPlus.x = Math.floor(Math.random() * (innerWidth - 100) + 100);
            lastPlus.y = -100;
            app.stage.addChild(lastPlus);
        }

        function MakeFallingPlus() {
            state.pluses.falling.push(new PIXI.Text("+", config.styles.greenPlus));
            let lastPlus = state.pluses.falling[state.pluses.falling.length - 1];
            createPlus(lastPlus)
            state.plusFell = true;
        } //Функция которая пушит первый плюс отдельно от других--------------------------------------------------------
        function MakerotatePluses() {
            state.pluses.rotate.push(new PIXI.Text("+", config.styles.greenPlus));
            let lastPlus = state.pluses.rotate[state.pluses.rotate.length - 1];
            createPlus(lastPlus)
            state.rotatePlFell = true
        }

        function PlusPushingLogic() {
            if (state.plusFell) {
                setTimeout(MakeFallingPlus, state.intervalOfFallingPluses.falling);
                state.plusFell = false;
            }
            if (state.rotatePlFell) {
                if (state.difficult > 1) {
                    //setTimeout(MakerotatePluses, state.intervalOfFallingPluses.rotate)
                    state.rotatePlFell = false
                }
            }

        }
        //Функция которая пушит плюсы рядом с "Ш" --------------------------------------------------------------------
        function PlusOnPlace(X, Y) {
            state.pluses.onPlace.push(new PIXI.Text("+", config.styles.greenPlus))
            let lastPlus = state.pluses.onPlace[state.pluses.onPlace.length - 1]
            lastPlus.x = X;
            lastPlus.y = Y;
            lastPlus.Transform = false;
            lastPlus.rotationStep = Math.random() * config.rotationRandomizer;
            lastPlus.shag = {};
            lastPlus.catched = true;
            lastPlus.Xshag = Math.floor(Math.random() * config.sizesForRandom.x);
            lastPlus.Yshag = Math.floor(Math.random() * config.sizesForRandom.y);
            app.stage.addChild(lastPlus)
        }

        function createGoldPlus() {
            if (TransformPlusDelete()) {
                let gold = state.pluses.gold;
                gold.push(new PIXI.Text("+", config.styles.goldPlus));
                gold[gold.length - 1].x = config.center.x;
                gold[gold.length - 1].Xshag = Math.floor(Math.random() * config.sizesForRandom.x)
                gold[gold.length - 1].Yshag = Math.floor(Math.random() * config.sizesForRandom.y)
                gold[gold.length - 1].rotationStep = Math.random() * config.rotationRandomizer
                gold[gold.length - 1].y = config.center.y;
                gold[gold.length - 1].catched = false;
                app.stage.addChild(gold[gold.length - 1]);
            }
        }
        /*=============================================================================================
        MOVING ALL
        =============================================================================================*/
        //Функция которая меняет положение Ш если наажата стрелочка лево/право ---------------------------------------
        function MoveSh() {
            if (state.rightPressed && state.sh.x + config.fontSize < innerWidth) {

                state.sh.x += config.shSpeed;

            }
            if (state.leftPressed && 0 < state.sh.x) {

                state.sh.x -= config.shSpeed;

            }
        }

        //Функция которая двигает плюсы во время взрыва Ш ------------------------------------------------------------
        function BoomPlusesMove() {
            for (let r = 0; r < state.pluses.boom.length; r++) {
                state.pluses.boom[r].x += state.pluses.boom[r].xShag;
                state.pluses.boom[r].y += state.pluses.boom[r].yShag;
                state.pluses.boom[r].yShag += state.pluses.gravity;
                state.pluses.boom[r].rotation += state.pluses.boom[r].rotationStep
            }
            DeletingGreyPlusesAfterBlast();
        }
        //Функция которая двигает падающие плюсы----------------------------------------------------------------------
        function PlusMover() {
            for (let i = 0; i < state.pluses.falling.length; i++) {
                if (!state.pluses.falling[i].catched) {
                    if (state.timeWhenFunctionsDone >= 3) {
                        state.pluses.falling[i].y += state.pluses.falling[i].speed * state.timeWhenFunctionsDone;
                    } else {
                        state.pluses.falling[i].y += state.pluses.falling[i].speed;
                    }
                }
            }
        }

        function isAllGoldPlusesCatched() {
            for (let i = 0; i < state.pluses.gold.length; i++) {
                if (!state.pluses.gold[i].catched) {
                    state.allGoldCatched = false;
                } else {
                    state.allGoldCatched = true;
                }
            }
        }
        //Функция которая взрывает словленные плюсы ------------------------------------------------------------------
        function blastPL(parentPlus, typeofPlus, a) {
            let length = parentPlus.length
            for (let i = a - 1; i < length; i++) {
                app.stage.removeChild(parentPlus[parentPlus.length - 1])
                parentPlus.pop();
                state.score -= typeofPlus;
            }
        }

        function BlastPlusesNextSh() {
            if (state.pushPlusNextSh && state.deadPlus.value > 0) {
                BoomPush();
                if (state.pluses.gold.length > 0 && state.deadGoldPlus.value > 0) {
                    blastPL(state.pluses.gold, 5, state.deadGoldPlus.value)
                }
                blastPL(state.pluses.onPlace, 1, state.deadPlus.value)
                state.pushPlusNextSh = false;
            }
        }
        //Функция которая удаляет мерые плюсы которые упали за канвас ------------------------------------------------
        function DeletingGreyPlusesAfterBlast() {
            if (state.pluses.boom.map(({
                    y
                }) => y).filter(a => a != undefined).every(a => a > innerHeight)) {
                for (let i = 0; i < state.pluses.boom.length; i++) {
                    app.stage.removeChild(state.pluses.boom[i])
                }
                for (let i = 0; i < state.pluses.boom.length; i++) {
                    state.pluses.boom.pop
                }

            }
        }
        //Функция которая заканчивает игру если плюс попал в букву Ш -------------------------------------------------
        function GameOver() {
            for (let i = 0; i < state.pluses.falling.length; i++) {
                let falling = state.pluses.falling[i]
                let plusSize = state.plusRealSize
                if (falling.y > state.shSizes.y - state.shSizes.h &&
                    falling.y < state.shSizes.y) {
                    if (falling.x > state.shSizes.x &&
                        falling.x < state.shSizes.x + state.shSizes.w &&
                        falling.x + plusSize.width > state.shSizes.x &&
                        falling.x + plusSize.width < state.shSizes.x + state.shSizes.w &&
                        !falling.catched &&
                        !falling.kill) {
                        state.stop = true;
                        falling.kill = true;
                        app.stage.removeChild(falling)
                    } else if (falling.x > state.shSizes.x &&
                        falling.x < state.shSizes.x + state.shSizes.w &&
                        !falling.catched &&
                        !falling.kill) {
                        state.stop = true;
                        falling.kill = true;
                        app.stage.removeChild(falling)
                    } else if (falling.x + plusSize.width > state.shSizes.x &&
                        falling.x + plusSize.width < state.shSizes.x + state.shSizes.w &&
                        !falling.catched &&
                        !falling.kill) {
                        state.stop = true;
                        falling.kill = true;
                        app.stage.removeChild(falling)
                    }
                }
            }
        }
        //Игровой счет -----------------------------------------------------------------------------------------------
        function GameScore() {
            state.scoreObject.text = state.score
            if (state.scoreAdd) {
                state.score += 1;
            }
            state.scoreAdd = false;
        }
        //Анимация взрыва плюсов -------------------------------------------------------------------------------------
        function GameOverBlastAnim() {
            for (let i = 0; i < state.pluses.gold.length; i++) {
                let goldPlus = state.pluses.gold[i]
                goldPlus.x += goldPlus.Xshag;
                goldPlus.y += goldPlus.Yshag;
                goldPlus.rotation += goldPlus.rotationStep;
                goldPlus.Yshag += config.gravity
            }
            for (let i = 0; i < state.pluses.onPlace.length; i++) {
                let PlusOnPlace = state.pluses.onPlace[i]
                PlusOnPlace.x += PlusOnPlace.Xshag;
                PlusOnPlace.y += PlusOnPlace.Yshag;
                PlusOnPlace.Yshag += config.gravity;
                PlusOnPlace.rotation += PlusOnPlace.rotationStep
            }
            state.sh.x += state.sh.shag.x;
            state.sh.y += state.sh.shag.y;
            state.sh.rotation += state.sh.rotationStep
            state.greyPlus.rotation += state.sh.rotationStep
            state.sh.shag.y += config.gravity;
            state.greyPlus.x += state.greyPlus.shag.x;
            state.greyPlus.y += state.greyPlus.shag.y;
            state.greyPlus.shag.y += config.gravity;
        }
        //Функции-маркеры нажатых кнопок------------------------------------------------------------------------------
        function KeyDownHandler(e) {
            if (e.keyCode === 39) {
                state.rightPressed = true;
            }
            if (e.keyCode === 37) {
                state.leftPressed = true;
            }
        }

        function KeyUpHandler(e) {
            if (e.keyCode === 39) {
                state.rightPressed = false;
            }
            if (e.keyCode === 37) {
                state.leftPressed = false;
            }
        }
        //Анимация ловли плюсов --------------------------------------------------------------------------------------
        function CatcherAnimCaller() {
            CatcherAnimSmth(state.pluses.falling)
        }

        function CatcherAnimSmth(y) {
            let pluses = y;
            if(state.pluses.falling.length > 1){
            for (plus of pluses) {
                if (plus.catched) {
                    let shagY = (state.greyPlus.y - plus.y) / 6;
                    let shagX = (state.greyPlus.x - plus.x) / 2;

                    if (plus.x < state.greyPlus.x && !plus.onPlace) {
                        plus.x += shagX;
                    }
                    if (plus.x > state.greyPlus.x && !plus.onPlace) {
                        plus.x += shagX;
                    }
                    if (plus.y < state.greyPlus.y && !plus.onPlace) {
                        plus.y += shagY;
                    }
                    if (plus.y > state.greyPlus.y - 1 && !plus.onPlace) {
                        plus.y = state.greyPlus.y
                        plus.x = state.greyPlus.x
                        plus.onPlace = true;
                        state.scoreAnimDo = true;
                        state.scoreAnimRemoveVariables = true;
                        state.scoreAdd = true;
                        PlusOnPlace(plus.x, plus.y)
                        app.stage.removeChild(plus)
                        state.scoreDecreasMarker += 1;
                    }
                }
            }
        }
    }

        function sayIfScoreDecreased() {
            if (state.scoreDecreasMarker > state.score) {
                state.scoreMinusAnim = true;
                state.scoreDecreasMarker = state.score;
            }
        }
        //Функция которая удаляет падающий плюс и пушит плюс рядом с "Ш" ---------------------------------------------
        function catchSmth(a, b) {
            for (let i = 0; i < a; i++) {
                let fallin = b[i];
                if (
                    fallin.y < innerHeight - config.fontSize / 2.5 &&
                    fallin.y > innerHeight - config.fontSize * 2.5 &&
                    !fallin.catched &&
                    state.allGoldCatched

                ) {
                    if (
                        fallin.x > state.greyPlus.x - config.fontSize / 2 &&
                        fallin.x < state.greyPlus.x + config.fontSize / 2 &&
                        !fallin.kill
                    ) {
                        fallin.catched = true;
                    }
                }
            }

        }

        function PlusCatcher() {
            catchSmth(state.pluses.falling.length, state.pluses.falling)
            if (state.difficult > 0 && state.difficult < 3) {
                catchSmth(state.pluses.rotate.length, state.pluses.rotate)
            }
        }
        //золотой плюс
        function GoldPlus() {
            if (state.pluses.onPlace.length % 5 === 0) {
                let length = state.pluses.onPlace.length
                for (let i = 0; i < length; i++) {
                    let plus = state.pluses.onPlace[i];
                    let tr = state.pluses.Transform
                    tr.push(new PIXI.Text("+", config.styles.greenPlus))
                    tr[tr.length - 1].x = plus.x
                    tr[tr.length - 1].y = plus.y
                    app.stage.addChild(tr[tr.length - 1])
                    app.stage.removeChild(plus)
                }
                state.canAnimTransform = true
                for (let i = 0; i < length; i++) {
                    state.pluses.onPlace.pop()
                }
            }

        }

        function GoldPlAnim() {
            if (state.canAnimTransform) {
                for (let i = 0; i < state.pluses.Transform.length; i++) {
                    let animpl = state.pluses.Transform[i];
                    animpl.x -= (animpl.x - config.center.x) / config.animGoldPlusSpeed
                    animpl.y += (config.center.y - animpl.y) / config.animGoldPlusSpeed
                }
            }
        }

        function GoldCatcher() {
            let lastGold = state.pluses.gold[state.pluses.gold.length - 1];
            let gold = state.pluses.gold
            let grey = state.greyPlus
            if (state.pluses.gold.length > 0) {
                if (1 > grey.y - lastGold.y &&
                    grey.x - lastGold.x < 1) {
                    lastGold.catched = true;
                }
            }
            state.catchedGoldPluses = 0;
            for (let i = 0; i < gold.length; i++) {
                if (gold[i].catched) {
                    state.catchedGoldPluses += 1;
                }
            }
        }

        function TransformPlusDelete() {
            let length = state.pluses.Transform.length
            let bool = false
            if (length > 0) {
                if (state.pluses.Transform[0].y < config.center.y + 1) {
                    bool = true
                }
            }
            if (bool) {
                for (let i = length - 1; i > -1; i--) {
                    app.stage.removeChild(state.pluses.Transform[state.pluses.Transform.length - 1]);
                    state.pluses.Transform.pop()
                }
            }
            return (bool)
        }

        function GoldPlusMove() {
            let gold = state.pluses.gold
            if (gold.length > 0 && !gold[gold.length - 1].catched) {
                gold[gold.length - 1].x -= Math.floor((gold[gold.length - 1].x - state.greyPlus.x) / config.animGoldPlusSpeed)
                gold[gold.length - 1].y -= Math.floor((gold[gold.length - 1].y - state.greyPlus.y) / config.animGoldPlusSpeed)
            }
        }
        //Функция которая анимирует счет когда плюс словлен ----------------------------------------------------------
        function ScoreAnimPlus() {
            if (state.scoreColorAlpha < 1) {
                state.scoreObject.style.fill = 'rgba(0,128,0,' + state.scoreColorAlpha + ')';
                state.scoreColorAlpha += 0.05;
                state.scoreObject.style.stroke = 'rgba(0,128,0,' + state.scoreColorAlpha + ')';

            }
            if (state.scoreObject.y >= config.fontSize) {
                state.scoreSpeed = -10;
                state.scoreAnimSwitch = true;

            }
            if (state.gravity < 2) {
                state.scoreObject.y += state.scoreSpeed;
            }

            if (state.scoreAnimSwitch && state.scoreSpeed < 15) {
                state.scoreSpeed += state.gravity;
                state.gravity += 0.04;

            }
        }

        function difficultGame() {
            state.difficult = state.pluses.gold.length
            if (state.difficult === 0) {
                di.style.backgroundColor = "#DAF7A6";
            }
            if (state.difficult === 1) {
                di.style.backgroundColor = "#FFDA62";
            }
            if (state.difficult === 2) {
                di.style.backgroundColor = "#FF937B";
            }
            if (state.difficult === 3) {
                di.style.backgroundColor = "#C70039";
            }
            if (state.difficult === 4) {
                di.style.backgroundColor = "#900C3F";
            }
        }
        //Функция которая обнуляпт переменные счета перед анимацией --------------------------------------------------
        function ScoreVariablesRemove() {
            if (state.scoreAnimRemoveVariables) {
                state.scoreObject.y = 0;
                state.scoreSpeed = 15;
                state.scoreColorAlpha = 0;
                state.gravity = 0;
                state.scoreObject.style.stroke = 'rgba(0,0,0,0)'
                state.scoreAnimSwitch = false;
                state.scoreAnimRemoveVariables = false;
            }
            ScoreAnimPlus();
        }
        //Функция которая говорит номер выбитого плюса ---------------------------------------------------------------
        function SayNumberKnockedPlusCaller() {
            SayNumberKnockedPlus(state.pluses.gold, state.deadGoldPlus)
            SayNumberKnockedPlus(state.pluses.onPlace, state.deadPlus)
        }

        function SayNumberKnockedPlus(plus, dead) {
            for (let i = 0; i < state.pluses.falling.length; i++) {
                for (let a = 0; a < plus.length; a++) {
                    let falling = state.pluses.falling[i];
                    let plusDist = config.catchedPlusesDist;
                    if (plus[a].x < falling.x + plusDist / 2 &&
                        plus[a].x + plusDist > falling.x + plusDist / 2 &&
                        !falling.catched &&
                        !falling.kill &&
                        !plus[a].Transform &&
                        plus[a].catched) {
                        if (plus[a].y > falling.y &&
                            plus[a].y - plusDist < falling.y) {
                            dead.value = a + 1;
                            state.pushPlusNextSh = true;
                            falling.kill = true;
                            app.stage.removeChild(falling)
                            return;
                        }
                    }
                }
            }
        }
        //Функция которая обновляет переменные -----------------------------------------------------------------------
        function Update() {
            state.shSizes.w = state.shRealSize.width
            state.shSizes.h = state.shRealSize.height
            state.shSizes.x = state.sh.x
            state.shSizes.y = state.sh.y + state.shRealSize.height / 2
            for (let i = 0; i < state.pluses.falling.length; i++) {
                if (state.pluses.falling[i].y > innerHeight) {
                    state.pluses.falling.splice(i, 1)
                }
            }
            if (state.pluses.gold.length > 0) {
                for (let i = 0; i < state.pluses.gold.length; i++) {
                    if (state.pluses.gold[i].catched) {
                        state.pluses.gold[i].x = state.sh.x + config.greyDist + (config.catchedPlusesDist * (1 + i))
                    }
                }
            }
            if (state.pluses.onPlace.length > 0) {
                state.greyPlus.x = state.sh.x + config.greyDist + (config.catchedPlusesDist * (state.pluses.onPlace.length + 1 + state.catchedGoldPluses))
                state.greyPlus.y = state.sh.y
                for (let i = 0; i < state.pluses.onPlace.length; i++) {
                    state.pluses.onPlace[i].x = state.sh.x + config.greyDist + (config.catchedPlusesDist * (1 + i + state.catchedGoldPluses))
                }
            } else {
                state.greyPlus.x = state.sh.x + config.greyDist + config.catchedPlusesDist * (state.pluses.onPlace.length + 1 + state.catchedGoldPluses)
                state.greyPlus.y = state.sh.y
            }
        }

        function Start() {
            state.startText = document.createElement('div');
            state.startText.id = 'start'
            state.startText.style.overflow = 'hidden'
            state.startText.style.fontFamily = "Play"
            state.startText.innerHTML = config.replics.start[state.replic]
            state.startText.style.verticalAlign = 'middle'
            state.startText.style.textAlign = 'center'
            state.startText.style.lineHeight = innerHeight + 'px'
            state.startText.style.fontSize = 100 + "px"
            state.startText.style.position = "absolute"
            state.startText.style.width = innerWidth + "px";
            state.startText.style.height = innerHeight + "px";
            state.startText.style.transition = 'all 4s'
            state.startText.style.color = "rgba(0,0,0,1)"

            document.body.appendChild(state.startText)
            state.move = 5;
        }
        state.startGame = false
        Start();
        state.startTextTime = 2.9

        function animStartText() {
            if (!state.startGame) {
                state.startText.style.transition = "all " + state.startTextTime + "s"
                state.startText.style.color = "rgba(0,0,0,0)"
                state.startText.style.filter = "blur(5px)"
                state.startText.style.transform = "scale(1.5)"
            }
        }

        function nullAnimStartText() {
            state.replic++;
            state.startText.style.transition = "none"
            state.startText.style.filter = "none"
            state.startText.style.transform = "scale(1)"
            state.startText.style.verticalAlign = 'middle'
            state.startText.style.textAlign = 'center'
            state.startText.style.lineHeight = innerHeight + 'px'
            state.startText.style.fontSize = 50 + "px"
            state.startText.style.position = "absolute"
            state.startText.style.width = innerWidth + "px";
            state.startText.style.height = innerHeight + "px";
            state.startText.innerHTML = config.replics.start[state.replic]
            // if(state.replic > 3){
            // 	state.startTextTime = 1;
            // 	state.animSpeed = 2
            // }
            if (state.replic > 6) {
                state.startGame = true
                state.startTextTime = 1
                state.startText.innerHTML = ""
            }
            state.startText.style.color = "rgba(0,0,0,1)"
        }
        state.animSpeed = 1;
        if (state.animSpeed == 1) {
            setInterval(() => {
                animStartText();
                setTimeout(() => {
                    nullAnimStartText();
                }, state.startTextTime * 1000 + 80)
            }, state.startTextTime * 1000 + 100)
        } else {
            setInterval(() => {
                animStartText();
                setTimeout(() => {
                    nullAnimStartText();
                }, state.startTextTime * 1000 + 80)
            }, state.startTextTime * 1000 + 100)
        }


        //Вызов функций ----------------------------------------------------------------------------------------------

        app.ticker.add(() => {
            if (state.startGame) {
                state.timeNow = Date.now()
                if (!state.stop) {
                    PlusCatcher();
                    GoldPlusMove();
                    GameScore();
                    BlastPlusesNextSh();
                    createGoldPlus();
                    Update();
                    isAllGoldPlusesCatched()
                    BoomPlusesMove();
                    MoveSh();
                    PlusPushingLogic();
                    PlusMover();
                    CatcherAnimCaller();
                    SayNumberKnockedPlusCaller();
                    ScoreVariablesRemove();
                    GoldPlus();
                    GoldPlAnim();
                    GoldCatcher();
                    difficultGame();
                } else {
                    GameOverBlastAnim();
                }
                GameOver();
                state.timeWhenFunctionsDone = Date.now() - state.timeNow
            }
        });
    </script>
</body>

</html>
